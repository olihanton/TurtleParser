
————————————————————————————————————————————————
How has this interpreter implemented ‘DO’ loops?
————————————————————————————————————————————————

This should be suitably explained in the code. I have included this document for further detail on the development process.

‘DO loops’ are implemented in this interpreter within the function ‘code()’. At the parsing stage our function ‘code()’ is set up to end the recursive interpreting if if comes across a ‘}’ symbol. In order to avoid the ‘code()’ ending the reading of the program if it comes across the end of a ‘DO loop’ we use a temporary flag called ‘doloopflag’. ‘Doloopflag’ increments by one every time a ‘DO loop’ is started and ‘code()’ won’t end if it comes across a ‘}’ and ‘doloopflag’>0. ‘Doloopflag’ must also reduce by one every time that ‘code()’ comes across a ‘}’.

This gives our structure for implementing ‘DO loops’. We take any point in the code and think of any ‘DO loop’ which has been called but doesn’t have a corresponding closing brace as open and any other ‘DO loop’ we may come across as closed. Using this method, ‘doloopflag’ tells us how many ‘DO loops’ are currently open. If we have no nested ‘DO loops’ then throughout such a program, ‘doloopflag’ will only ever be 1 or 0. We can think of nested ‘DO loops’ as different levels of looping within our code. For instance if at any point in the code we have a ‘doloopflag’=3 then we know that we are currently within a ‘DO loop’ which is nested in a ‘DO loop’ which is nested in a further ‘DO loop’. We can think of the two ‘DO loops’ that this third loop is nested in as having ‘doloopflags’ of 1 and 2 respectively but a higher flag overrides them. As such every ‘DO loop’ will have a ‘doloopflag’ value for its entirety unless it contains a further ‘DO loop’. Crucially this means that at any one time there will only be one ‘DO loop’ flag associated with each integer from 1 to n where n=‘doloopflag’. 

Using this logic we look at the function ‘executedo()’ which gives every ‘DO loop’ a length (the number of tokens the ‘DO loop’ contains) and a count (the number of times that the ‘DO loop’ loops). By storing these within the structure Program in arrays called ‘length’ and ‘cnt’ respectively we have enough information that when the function ‘code()’ wants to execute a ‘DO loop’ recursively if can merely by looking at the level/‘doloopflag’ that that particular ‘DO loop’ is on. If a ‘DO loop’ closes and another is opened which subsequently has a same ‘doloopflag’ then its respective cnt and length values are overwritten.  